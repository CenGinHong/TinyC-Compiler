/* Generated By:JJTree&JavaCC: Do not edit this line. MyCompiler.java */

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.*;

class MyCompiler/*@bgen(jjtree)*/ implements MyCompilerTreeConstants, MyCompilerConstants {/*@bgen(jjtree)*/
    protected JJTMyCompilerState jjtree = new JJTMyCompilerState();
    private ErrorList errorList = new ErrorList();
    private SymbolTable symbolTable = new SymbolTable();
    private CodeGen codeGen = new CodeGen(false);

    public static void main(String[] args) throws TokenMgrError, FileNotFoundException, ParseException {

        String path = "C:\\Users\\CJH\\IdeaProjects\\test1\\test.txt";
        FileInputStream fileInputStream = new FileInputStream(new File(path));
        MyCompiler parser = new MyCompiler(fileInputStream);
        parser.program();
        SimpleNode node = (SimpleNode) parser.jjtree.rootNode();
        node.dump("");
        parser.errorList.printError();
        List<String> qt = parser.codeGen.getQt();
        for (String q : qt) {
            System.out.println(q);
        }
    }

    //program -> declaration-list
    final public void program() throws ParseException {
        /*@bgen(jjtree) program */
        ASTprogram jjtn000 = new ASTprogram(JJTPROGRAM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token id;
        try {
            HashMap<String, VarInfo> map = new HashMap<String, VarInfo>();
            symbolTable.getVarList().add(map);
            codeGen.emitRM(codeGen.OP_LD, codeGen.REG_MP, 0, codeGen.REG_AC, "load maxaddress from location 0");
            codeGen.emitRM(codeGen.OP_ST, codeGen.REG_AC, 0, codeGen.REG_AC, "clear location 0");
            codeGen.emitRM(codeGen.OP_LDA, codeGen.REG_LP, 0, codeGen.REG_GP, "init lp");
            codeGen.emitRM(codeGen.OP_LDA, codeGen.REG_SP, 0, codeGen.REG_GP, "init sp");
            declarationList();
            id = jj_consume_token(0);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            if (!"main".equals(symbolTable.getLatestDeclarationFun().getName())) {
                errorList.addLastNotMain(id);
            }
            //leave a  block,remove a new hashmap
            symbolTable.getVarList().remove(symbolTable.getVarList().size() - 1);
            codeGen.emitRO(codeGen.OP_HALT, 0, 0, 0, "");
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    //declaration-list -> declaration{ declaration}
    final public void declarationList() throws ParseException {
        /*@bgen(jjtree) declarationList */
        ASTdeclarationList jjtn000 = new ASTdeclarationList(JJTDECLARATIONLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        try {
            declaration();
            label_1:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case INT:
                    case VOID:
                        ;
                        break;
                    default:
                        jj_la1[0] = jj_gen;
                        break label_1;
                }
                declaration();
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    //declaration -> var-declaration | fun-declaration
    final public void declaration() throws ParseException {
        /*@bgen(jjtree) declaration */
        ASTdeclaration jjtn000 = new ASTdeclaration(JJTDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        try {
            if (jj_2_1(2147483647)) {
                varDeclaration();
            } else {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case INT:
                    case VOID:
                        funDeclaration();
                        break;
                    default:
                        jj_la1[1] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

//var-declaration -> type-specifier ID; | type-specifier ID[NUM];

    /**
     * var-declaration -> type-specifier ID; | type-specifier ID[NUM];
     * Âõ†‰∏∫Âè™ËÉΩÂÆö‰πâintÂèòÈáèÂíåÊï∞ÁªÑÔºåÊïÖ‰øÆÊî?
     * var-declaration -> int ID; | int ID[NUM];
     */
    final public void varDeclaration() throws ParseException {
        /*@bgen(jjtree) varDeclaration */
        ASTvarDeclaration jjtn000 = new ASTvarDeclaration(JJTVARDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        Token id;
        VarInfo var;
        Token size;
        try {
            if (jj_2_2(2147483647)) {
                jj_consume_token(INT);
                id = jj_consume_token(ID);
                jj_consume_token(SEMICOLON);
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
                var = new VarInfo("int", id);
                var.setSize(1);
                if (!symbolTable.addVar(var)) {
                    errorList.addVarHaveDeclared(id);
                } else {
                    codeGen.emitRM(codeGen.OP_LDA, codeGen.REG_SP, 1, codeGen.REG_SP, "var local ins sp");
                    if (symbolTable.isGlobalVar(id.image)) {
                        codeGen.emitRM(codeGen.OP_LDA, codeGen.REG_LP, 1, codeGen.REG_LP, "var global ins sp");
                    }
                }
            } else {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case INT:
                        jj_consume_token(INT);
                        id = jj_consume_token(ARRAYELEMENT);
                        size = jj_consume_token(NUM);
                        jj_consume_token(RIGHTBRACKET);
                        jj_consume_token(SEMICOLON);
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                        id.image = id.image.replace("[", "");
                        var = new VarInfo("int[]", id);
                        var.setSize(Integer.parseInt(size.image));
                        if (!symbolTable.addVar(var)) {
                            errorList.addVarHaveDeclared(id);
                        } else {
                            codeGen.emitRM(codeGen.OP_LDA, codeGen.REG_SP, Integer.parseInt(size.image), codeGen.REG_SP, "var[] local ins sp");
                            if (symbolTable.isGlobalVar(id.image)) {
                                codeGen.emitRM(codeGen.OP_LDA, codeGen.REG_LP, Integer.parseInt(size.image), codeGen.REG_LP, "var global ins sp");
                            }
                        }
                        break;
                    default:
                        jj_la1[2] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    //fun-declaration -> type-specifier ID (params) | compound-stmt
    final public void funDeclaration() throws ParseException {
        /*@bgen(jjtree) funDeclaration */
        ASTfunDeclaration jjtn000 = new ASTfunDeclaration(JJTFUNDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token id;
        Token returnType;
        FunInfo fun;
        List<VarInfo> par;
        int callFunLoc = 0;
        int jumpLoc = 0;
        int currentLoc = 0;
        try {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case INT:
                    returnType = jj_consume_token(INT);
                    id = jj_consume_token(ID);
                    jj_consume_token(LEFTPARENTHESES);
                    par = params();
                    jj_consume_token(RIGHTPARENTHESES);
                    if (!"main".equals(id.image)) {
                        jumpLoc = codeGen.emitSkip(1);
                    }
                    //Define the function header, pay attention to record the return value
                    fun = new FunInfo(returnType.image, id, par);
                    callFunLoc = codeGen.emitSkip(0);
                    fun.setLoc(callFunLoc);
                    if (!symbolTable.addFun(fun)) {
                        errorList.addFunHaveDeclared(id);
                    } else {

                        List<VarInfo> tempFunPar = symbolTable.getTempFunPar();
                        tempFunPar.clear();
                        //add the symbol to it inorder to init the fun symbol
                        tempFunPar.addAll(par);
                    }
                    compoundStmt();
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    if (!"main".equals(id.image)) {
                        codeGen.emitRM(codeGen.OP_LDA, codeGen.REG_PC, 0, codeGen.REG_FP, "jump  back to caller");
                        currentLoc = codeGen.emitSkip(0);
                        codeGen.emitBackup(jumpLoc);
                        codeGen.emitRM_Abs(codeGen.OP_LDA, codeGen.REG_PC, currentLoc, "jmp to fun end");
                        codeGen.emitRestore();
                    }
                    break;
                case VOID:
                    returnType = jj_consume_token(VOID);
                    id = jj_consume_token(ID);
                    jj_consume_token(LEFTPARENTHESES);
                    par = params();
                    jj_consume_token(RIGHTPARENTHESES);
                    if (!"main".equals(id.image)) {
                        jumpLoc = codeGen.emitSkip(1);
                    }
                    //Define the function header, pay attention to record the return value
                    fun = new FunInfo(returnType.image, id, par);
                    callFunLoc = codeGen.emitSkip(0);
                    fun.setLoc(callFunLoc);
                    if (!symbolTable.addFun(fun)) {
                        errorList.addFunHaveDeclared(id);
                    } else {
                        List<VarInfo> tempFunPar = symbolTable.getTempFunPar();
                        tempFunPar.clear();
                        //add the symbol to it inorder to init the fun symbol
                        tempFunPar.addAll(par);
                    }
                    compoundStmt();
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    if (!"main".equals(id.image)) {
                        codeGen.emitRM(codeGen.OP_LDA, codeGen.REG_PC, 0, codeGen.REG_FP, "jump  back to caller");
                        currentLoc = codeGen.emitSkip(0);
                        codeGen.emitBackup(jumpLoc);
                        codeGen.emitRM_Abs(codeGen.OP_LDA, codeGen.REG_PC, currentLoc, "jmp to fun end");
                        codeGen.emitRestore();
                    }
                    break;
                default:
                    jj_la1[3] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    //params -> param-list | void
    final public List<VarInfo> params() throws ParseException {
        /*@bgen(jjtree) params */
        ASTparams jjtn000 = new ASTparams(JJTPARAMS);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        List<VarInfo> par;
        try {
            if (jj_2_3(2147483647)) {
                par = paramList();
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
                {
                    if (true) return par;
                }
            } else {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case VOID:
                        jj_consume_token(VOID);
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                    {
                        if (true) return Collections.emptyList();
                    }
                    break;
                    default:
                        jj_la1[4] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    //param-list -> param{ , param}
    final public List<VarInfo> paramList() throws ParseException {
        /*@bgen(jjtree) paramList */
        ASTparamList jjtn000 = new ASTparamList(JJTPARAMLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        List<VarInfo> par;
        VarInfo para;
        try {
            para = param();
            par = new ArrayList<VarInfo>();
            par.add(para);
            label_2:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                        ;
                        break;
                    default:
                        jj_la1[5] = jj_gen;
                        break label_2;
                }
                jj_consume_token(COMMA);
                para = param();
                par.add(para);
            }
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            {
                if (true) return par;
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * param -> type-specifier ID | type-specifier ID[]
     * ÊîπÈ?†ÊñáÊ≥?
     * param -> int ID | int ID[]
     */
    final public VarInfo param() throws ParseException {
        /*@bgen(jjtree) param */
        ASTparam jjtn000 = new ASTparam(JJTPARAM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token id;
        try {
            if (jj_2_4(2147483647)) {
                jj_consume_token(INT);
                id = jj_consume_token(ID);
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
                {
                    if (true) return new VarInfo("int", id.image);
                }
            } else {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case INT:
                        jj_consume_token(INT);
                        id = jj_consume_token(ARRAYELEMENT);
                        jj_consume_token(RIGHTBRACKET);
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                        id.image = id.image.replace("]", "");
                    {
                        if (true) return new VarInfo("int[]", id.image);
                    }
                    break;
                    default:
                        jj_la1[6] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    //compound-stmt -> {local-declarations statement-list}
    final public void compoundStmt() throws ParseException {
        /*@bgen(jjtree) compoundStmt */
        ASTcompoundStmt jjtn000 = new ASTcompoundStmt(JJTCOMPOUNDSTMT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        int paraSize = 0;
        int sp = 0;
        try {
            jj_consume_token(LEFTBRACES);
            //enter a new block,create a new hashmap
            HashMap<String, VarInfo> map = new HashMap<String, VarInfo>();
            symbolTable.getVarList().add(map);
            for (VarInfo e : symbolTable.getTempFunPar()) {
                if ("int".equals(e.getType())) {
                    e.setSize(1);
                } else {
                    e.setSize(50);
                }
                symbolTable.addVar(e);
                paraSize = e.getSize();
            }
            codeGen.emitRM(codeGen.OP_LDA, codeGen.REG_SP, paraSize, codeGen.REG_SP, "ins sp");
            symbolTable.getTempFunPar().clear();
            localDeclarations();
            statementList();
            //leave a  block,remove a new hashmap
            sp = symbolTable.reduceLocalSize();
            codeGen.emitRM(codeGen.OP_LDA, codeGen.REG_SP, -sp, codeGen.REG_SP, "des sp");
            symbolTable.getVarList().remove(symbolTable.getVarList().size() - 1);
            jj_consume_token(RIGHTBRACES);
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    //local-declarations -> empty{ var-declaration}
    final public void localDeclarations() throws ParseException {
        /*@bgen(jjtree) localDeclarations */
        ASTlocalDeclarations jjtn000 = new ASTlocalDeclarations(JJTLOCALDECLARATIONS);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        try {
            label_3:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case INT:
                        ;
                        break;
                    default:
                        jj_la1[7] = jj_gen;
                        break label_3;
                }
                varDeclaration();
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    //statement-list -> empty{ statement}
    final public void statementList() throws ParseException {
        /*@bgen(jjtree) statementList */
        ASTstatementList jjtn000 = new ASTstatementList(JJTSTATEMENTLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        try {
            label_4:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case IF:
                    case WHILE:
                    case RETURN:
                    case OUTPUT:
                    case INPUT:
                    case ID:
                    case NUM:
                    case SEMICOLON:
                    case LEFTPARENTHESES:
                    case ARRAYELEMENT:
                    case LEFTBRACES:
                        ;
                        break;
                    default:
                        jj_la1[8] = jj_gen;
                        break label_4;
                }
                statement();
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    //statement -> expression-stmt | compound-stmt | selection-stmt | iteration-stmt | return stmt
    final public void statement() throws ParseException {
        /*@bgen(jjtree) statement */
        ASTstatement jjtn000 = new ASTstatement(JJTSTATEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        try {
            if (jj_2_5(2147483647)) {
                expressionStmt();
            } else if (jj_2_6(2147483647)) {
                compoundStmt();
            } else if (jj_2_7(2147483647)) {
                selectionStmt();
            } else {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case WHILE:
                        iterationStmt();
                        break;
                    case RETURN:
                        returnStmt();
                        break;
                    default:
                        jj_la1[9] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    //expression-stmt -> expression; | ;
    final public void expressionStmt() throws ParseException {
        /*@bgen(jjtree) expressionStmt */
        ASTexpressionStmt jjtn000 = new ASTexpressionStmt(JJTEXPRESSIONSTMT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        try {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case OUTPUT:
                case INPUT:
                case ID:
                case NUM:
                case LEFTPARENTHESES:
                case ARRAYELEMENT:
                    expression();
                    jj_consume_token(SEMICOLON);
                    break;
                case SEMICOLON:
                    jj_consume_token(SEMICOLON);
                    break;
                default:
                    jj_la1[10] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    //selection-stmt -> matched-stmt | unmatched-stmt
    final public void selectionStmt() throws ParseException {
        /*@bgen(jjtree) selectionStmt */
        ASTselectionStmt jjtn000 = new ASTselectionStmt(JJTSELECTIONSTMT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        int savedLoc1 = 0;
        int savedLoc2 = 0;
        int currentLoc = 0;
        Token exp;
        try {
            if (jj_2_8(2147483647)) {
                jj_consume_token(IF);
                jj_consume_token(LEFTPARENTHESES);
                exp = expression();
                if (!"int".equals(exp.type)) {
                    errorList.addVarNotDeclared(exp);
                } else {
                    savedLoc1 = codeGen.emitSkip(1);
                }
                jj_consume_token(RIGHTPARENTHESES);
                statement();
                savedLoc2 = codeGen.emitSkip(1);
                currentLoc = codeGen.emitSkip(0);
                codeGen.emitBackup(savedLoc1);
                codeGen.emitRM_Abs(codeGen.OP_JEQ, codeGen.REG_AC, currentLoc, "if: jmp to else");
                codeGen.emitRestore();
                jj_consume_token(ELSE);
                statement();
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
                currentLoc = codeGen.emitSkip(0);
                codeGen.emitBackup(savedLoc2);
                codeGen.emitRM_Abs(codeGen.OP_LDA, codeGen.REG_PC, currentLoc, "if jmp to end");
                codeGen.emitRestore();
            } else {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case IF:
                        jj_consume_token(IF);
                        jj_consume_token(LEFTPARENTHESES);
                        exp = expression();
                        if (!"int".equals(exp.type)) {
                            errorList.addExpSubscript(exp);
                        } else {
                            savedLoc1 = codeGen.emitSkip(1);
                        }
                        jj_consume_token(RIGHTPARENTHESES);
                        statement();
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                        currentLoc = codeGen.emitSkip(0);
                        codeGen.emitBackup(savedLoc1);
                        codeGen.emitRM_Abs(codeGen.OP_JEQ, codeGen.REG_AC, currentLoc, "if: jmp to end");
                        codeGen.emitRestore();
                        break;
                    default:
                        jj_la1[11] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    //iteration-stmt -> while (expression) statement
    final public void iterationStmt() throws ParseException {
        /*@bgen(jjtree) iterationStmt */
        ASTiterationStmt jjtn000 = new ASTiterationStmt(JJTITERATIONSTMT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        int savedLoc1 = 0;
        int savedLoc2 = 0;
        int currentLoc = 0;
        Token exp;
        try {
            jj_consume_token(WHILE);
            jj_consume_token(LEFTPARENTHESES);
            savedLoc1 = codeGen.emitSkip(0);
            exp = expression();
            if (!"int".equals(exp.type)) {
                errorList.addLeftAndRightNotInt(exp);
            } else {
                savedLoc2 = codeGen.emitSkip(1);
            }
            jj_consume_token(RIGHTPARENTHESES);
            statement();
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            codeGen.emitRM_Abs(codeGen.OP_LDA, codeGen.REG_PC, savedLoc1, "while unconditional jmp");

            currentLoc = codeGen.emitSkip(0);
            codeGen.emitBackup(savedLoc2);
            codeGen.emitRM_Abs(codeGen.OP_JEQ, codeGen.REG_AC, currentLoc, "while out of body");
            codeGen.emitRestore();
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    //return-stmt -> return; | return expression;
    final public void returnStmt() throws ParseException {
        /*@bgen(jjtree) returnStmt */
        ASTreturnStmt jjtn000 = new ASTreturnStmt(JJTRETURNSTMT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token retExp;
        try {
            if (jj_2_9(2147483647)) {
                retExp = jj_consume_token(RETURN);
                jj_consume_token(SEMICOLON);
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
                //Ê£?Êü•ËøîÂõûÂ?ºÊòØÂê¶ÂíåÂáΩÊï∞Â§¥ÂÆö‰πâÁöÑ‰∏?Ëá?
                if ("void".equals(symbolTable.getLatestDeclarationFun().getReturnType())) {
                    String errorInfo = retExp.beginLine + ":" + retExp.beginColumn +
                            " The type of the return value is inconsistent with the function definition";
                    errorList.addError(errorInfo);
                }
            } else {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case RETURN:
                        jj_consume_token(RETURN);
                        retExp = expression();
                        jj_consume_token(SEMICOLON);
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                        //Ê£?Êü•ËøîÂõûÂ?ºÊòØÂê¶ÂíåÂáΩÊï∞Â§¥ÂÆö‰πâÁöÑ‰∏?Ëá?
                        if (!retExp.type.equals(symbolTable.getLatestDeclarationFun().getReturnType())) {
                            String errorInfo = retExp.beginLine + ":" + retExp.beginColumn +
                                    " The type of the return value is inconsistent with the function definition";
                            errorList.addError(errorInfo);
                        }
                        break;
                    default:
                        jj_la1[12] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    //expression -> var=expression | simple-expression
    final public Token expression() throws ParseException {
        /*@bgen(jjtree) expression */
        ASTexpression jjtn000 = new ASTexpression(JJTEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token left;
        Token right;
        int loc;
        String varName;
        try {
            if (jj_2_10(2147483647)) {
                left = var();
                varName = left.image;
                codeGen.emitRM(codeGen.OP_ST, codeGen.REG_AC1, codeGen.tmpOffset--, codeGen.REG_MP, "op: push index");
                jj_consume_token(ASSIGN);
                right = expression();
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
                //Ê£?Êü•Âè≥ËæπÊòØÂê¶‰∏∫intÁ±ªÂûãÁöÑË°®ËææÂºè
                if (!"int".equals(right.type)) {
                    errorList.addLeftIsNotInt(right);
                } else {
                    if (varName.contains("[")) {
                        varName = varName.substring(0, varName.indexOf("["));
                    }
                    codeGen.emitRM(codeGen.OP_LD, codeGen.REG_AC1, ++codeGen.tmpOffset, codeGen.REG_MP, "op: load index");
                    if (symbolTable.isGlobalVar(varName)) {
                        codeGen.emitRM(codeGen.OP_STS, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_GP, "assign: global store value");
                    } else {
                        codeGen.emitRM(codeGen.OP_STS, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_LP, "assign: local store value");
                    }
                }
                left.type = "void";
                //the type of assgin is void
                {
                    if (true) return left;
                }
            } else {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case OUTPUT:
                    case INPUT:
                    case ID:
                    case NUM:
                    case LEFTPARENTHESES:
                    case ARRAYELEMENT:
                        left = simpleExperession();
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                    {
                        if (true) return left;
                    }
                    break;
                    default:
                        jj_la1[13] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    //var -> ID| ID[expression]
    final public Token var() throws ParseException {
        /*@bgen(jjtree) var */
        ASTvar jjtn000 = new ASTvar(JJTVAR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token id;
        Token exp;
        VarInfo var;
        int loc;
        try {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case ID:
                    id = jj_consume_token(ID);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    var = symbolTable.checkUndefined(id.image);
                    if (var == null) {
                        errorList.addVarNotDeclared(id);
                    } else if (!"int".equals(var.getType())) {
                        errorList.addVarNotDeclared(id);
                    } else {
                        loc = symbolTable.getVarLocByVarName(id.image);
                        codeGen.emitRM(codeGen.OP_LDC, codeGen.REG_AC1, loc, 0, "load const");
                        if (var.getGlobal()) {
                            codeGen.emitRM(codeGen.OP_LDS, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_GP, "load global id value");
                        } else {
                            codeGen.emitRM(codeGen.OP_LDS, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_LP, "load local id value");
                        }
                    }
                {
                    if (true) return id;
                }
                break;
                case ARRAYELEMENT:
                    id = jj_consume_token(ARRAYELEMENT);
                    exp = expression();
                    jj_consume_token(RIGHTBRACKET);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    id.image = id.image.replace("[", "");
                    var = symbolTable.checkUndefined(id.image);
                    if (var == null) {
                        errorList.addVarNotDeclared(id);
                    } else if (!"int[]".equals(var.getType())) {
                        errorList.addVarNotDeclared(id);
                    } else {
                        //Checks if the right side is an expression of type int
                        if (!"int".equals(exp.type)) {
                            errorList.addArraySubscript(exp);
                        } else {
                            //Get the starting index of the array
                            loc = symbolTable.getVarLocByVarName(id.image);
                            codeGen.emitRM(codeGen.OP_LDC, codeGen.REG_AC1, loc, 0, "load const");
                            //Get the corresponding index of the element
                            codeGen.emitRO(codeGen.OP_ADD, codeGen.REG_AC1, codeGen.REG_AC1, codeGen.REG_AC, "op +");
                            if (var.getGlobal()) {
                                codeGen.emitRM(codeGen.OP_LDS, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_GP, "load global id value");
                            } else {
                                codeGen.emitRM(codeGen.OP_LDS, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_LP, "load local id value");
                            }
                        }
                    }
                    id.image = id.image + "[" + exp.image + "]";
                    id.type = "int";
                {
                    if (true) return id;
                }
                break;
                default:
                    jj_la1[14] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    //simple-experession -> additive-expression (relop additive-expression)?
    final public Token simpleExperession() throws ParseException {
        /*@bgen(jjtree) simpleExperession */
        ASTsimpleExperession jjtn000 = new ASTsimpleExperession(JJTSIMPLEEXPERESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token ret;
        Token temp;
        Token re;
        try {
            ret = additiveExpression();
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case EQUAL:
                case NOTEQUAL:
                case LT:
                case GT:
                case LTE:
                case GTE:
                    re = relop();
                    codeGen.emitRO(codeGen.OP_ST, codeGen.REG_AC, codeGen.tmpOffset--, codeGen.REG_MP, "op: push left");
                    /* gen code for ac = right operand */

                    temp = additiveExpression();
                    //Âè™ÊúâintËÉΩÊØîËæÉÔºåÂΩì‰∏§‰∏™Êúâ‰∏?‰∏™‰∏çÊòØintÁ±ªÂûãÊó?
                    if (!"int".equals(ret.type) || !"int".equals(temp.type)) {
                        errorList.addLeftAndRightNotInt(ret);
                    } else {
                        codeGen.emitRO(codeGen.OP_LD, codeGen.REG_AC1, ++codeGen.tmpOffset, codeGen.REG_MP, "op: load left");
                        codeGen.emitRO(codeGen.OP_SUB, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_AC, "sub before relop");
                        switch (re.image) {
                            case "<=": {
                                codeGen.emitRM(codeGen.OP_JLE, codeGen.REG_AC, 2, codeGen.REG_PC, "op <=");
                                break;
                            }
                            case "<": {
                                codeGen.emitRM(codeGen.OP_JLT, codeGen.REG_AC, 2, codeGen.REG_PC, "op <");
                                break;
                            }
                            case ">": {
                                codeGen.emitRM(codeGen.OP_JGT, codeGen.REG_AC, 2, codeGen.REG_PC, "op >");
                                break;
                            }
                            case ">=": {
                                codeGen.emitRM(codeGen.OP_JGE, codeGen.REG_AC, 2, codeGen.REG_PC, "op >=");
                                break;
                            }
                            case "==": {
                                codeGen.emitRM(codeGen.OP_JEQ, codeGen.REG_AC, 2, codeGen.REG_PC, "op ==");
                                break;
                            }
                            case "!=": {
                                codeGen.emitRM(codeGen.OP_JNE, codeGen.REG_AC, 2, codeGen.REG_PC, "op !=");
                                break;
                            }
                            default:
                        }
                        codeGen.emitRM(codeGen.OP_LDC, codeGen.REG_AC, 0, codeGen.REG_AC, "false case");
                        codeGen.emitRM(codeGen.OP_LDA, codeGen.REG_PC, 1, codeGen.REG_PC, "unconditional jmp");
                        codeGen.emitRM(codeGen.OP_LDC, codeGen.REG_AC, 1, codeGen.REG_AC, "true case");
                    }
                    ret.type = "int";
                    break;
                default:
                    jj_la1[15] = jj_gen;
                    ;
            }
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            {
                if (true) return ret;
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    //relop -> <=|<|>|>=|==|!=
    final public Token relop() throws ParseException {
        /*@bgen(jjtree) relop */
        ASTrelop jjtn000 = new ASTrelop(JJTRELOP);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token id;
        try {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case LTE:
                    id = jj_consume_token(LTE);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                {
                    if (true) return id;
                }
                break;
                case LT:
                    id = jj_consume_token(LT);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                {
                    if (true) return id;
                }
                break;
                case GT:
                    id = jj_consume_token(GT);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                {
                    if (true) return id;
                }
                break;
                case GTE:
                    id = jj_consume_token(GTE);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                {
                    if (true) return id;
                }
                break;
                case EQUAL:
                    id = jj_consume_token(EQUAL);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                {
                    if (true) return id;
                }
                break;
                case NOTEQUAL:
                    id = jj_consume_token(NOTEQUAL);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                {
                    if (true) return id;
                }
                break;
                default:
                    jj_la1[16] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    //additive-expression -> term{ addop term}
    final public Token additiveExpression() throws ParseException {
        /*@bgen(jjtree) additiveExpression */
        ASTadditiveExpression jjtn000 = new ASTadditiveExpression(JJTADDITIVEEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token op;
        Token ret;
        Token temp;
        try {
            ret = term();
            label_5:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case PLUS:
                    case MINUS:
                        ;
                        break;
                    default:
                        jj_la1[17] = jj_gen;
                        break label_5;
                }
                op = addop();
                codeGen.emitRO(codeGen.OP_ST, codeGen.REG_AC, codeGen.tmpOffset--, codeGen.REG_MP, "op: push left");
                /* gen code for ac = right operand */

                temp = term();
                //when one of them are not int
                if (!"int".equals(ret.type) || !"int".equals(temp.type)) {
                    errorList.addLeftAndRightNotInt(ret);
                } else {
                    codeGen.emitRO(codeGen.OP_LD, codeGen.REG_AC1, ++codeGen.tmpOffset, codeGen.REG_MP, "op: load left");
                    if ("+".equals(op.image)) {
                        codeGen.emitRO(codeGen.OP_ADD, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_AC, "op +");
                    } else {
                        codeGen.emitRO(codeGen.OP_SUB, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_AC, "op -");
                    }
                }
                ret.type = "int";
            }
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            {
                if (true) return ret;
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    //term -> factor{  mulop factor}
    final public Token term() throws ParseException {
        /*@bgen(jjtree) term */
        ASTterm jjtn000 = new ASTterm(JJTTERM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token op;
        Token ret;
        Token temp;
        try {
            ret = factor();
            label_6:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case TIMES:
                    case DIVIDE:
                        ;
                        break;
                    default:
                        jj_la1[18] = jj_gen;
                        break label_6;
                }
                op = mulop();
                codeGen.emitRO(codeGen.OP_ST, codeGen.REG_AC, codeGen.tmpOffset--, codeGen.REG_MP, "op: push left");
                /* gen code for ac = right operand */

                temp = factor();
                //judge whereter the left and right are both int
                if (!"int".equals(ret.type) || !"int".equals(temp.type)) {
                    errorList.addLeftAndRightNotInt(ret);
                } else {
                    codeGen.emitRO(codeGen.OP_LD, codeGen.REG_AC1, ++codeGen.tmpOffset, codeGen.REG_MP, "op: load left");
                    if ("*".equals(op.image)) {
                        codeGen.emitRO(codeGen.OP_MUL, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_AC, "op *");
                    } else {
                        codeGen.emitRO(codeGen.OP_DIV, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_AC, "op /");
                    }
                }
                ret.type = "int";
            }
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            {
                if (true) return ret;
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    //addop -> +|-
    final public Token addop() throws ParseException {
        /*@bgen(jjtree) addop */
        ASTaddop jjtn000 = new ASTaddop(JJTADDOP);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token id;
        try {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case PLUS:
                    id = jj_consume_token(PLUS);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                {
                    if (true) return id;
                }
                break;
                case MINUS:
                    id = jj_consume_token(MINUS);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                {
                    if (true) return id;
                }
                break;
                default:
                    jj_la1[19] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    //mulop -> *|/
    final public Token mulop() throws ParseException {
        /*@bgen(jjtree) mulop */
        ASTmulop jjtn000 = new ASTmulop(JJTMULOP);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token id;
        try {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case TIMES:
                    id = jj_consume_token(TIMES);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                {
                    if (true) return id;
                }
                break;
                case DIVIDE:
                    id = jj_consume_token(DIVIDE);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                {
                    if (true) return id;
                }
                break;
                default:
                    jj_la1[20] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    //factor -> (expression) | var | call | NUM
    final public Token factor() throws ParseException {
        /*@bgen(jjtree) factor */
        ASTfactor jjtn000 = new ASTfactor(JJTFACTOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        try {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case LEFTPARENTHESES:
                    jj_consume_token(LEFTPARENTHESES);
                    t = expression();
                    jj_consume_token(RIGHTPARENTHESES);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                {
                    if (true) return t;
                }
                break;
                default:
                    jj_la1[21] = jj_gen;
                    if (jj_2_11(2147483647)) {
                        t = call();
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                        {
                            if (true) return t;
                        }
                    } else {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case ID:
                            case ARRAYELEMENT:
                                t = var();
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
                                t.type = "int";
                            {
                                if (true) return t;
                            }
                            break;
                            case NUM:
                                t = jj_consume_token(NUM);
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
                                codeGen.emitRM(codeGen.OP_LDC, codeGen.REG_AC, Integer.parseInt(t.image), 0, "load const");
                                t.type = "int";
                            {
                                if (true) return t;
                            }
                            break;
                            default:
                                jj_la1[22] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                    }
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    //call -> ID(args)
    final public Token call() throws ParseException {
        /*@bgen(jjtree) call */
        ASTcall jjtn000 = new ASTcall(JJTCALL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token id;
        List<String> arList;
        int jumpLoc;
        try {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case ID:
                    id = jj_consume_token(ID);
                    FunInfo fun = symbolTable.getFunInfoByName(id.image);
                    if (fun == null) {
                        errorList.addFunNotDeclared(id);
                    } else {
                        //st lp to prepare arg
                        codeGen.emitRM(codeGen.OP_ST, codeGen.REG_SP, codeGen.tmpOffset--, codeGen.REG_MP, "push sp");
                        codeGen.emitRM(codeGen.OP_ST, codeGen.REG_LP, codeGen.tmpOffset--, codeGen.REG_MP, "push lp");
                        codeGen.emitRM(codeGen.OP_ST, codeGen.REG_FP, codeGen.tmpOffset--, codeGen.REG_MP, "push fp");
                    }
                    jj_consume_token(LEFTPARENTHESES);
                    arList = args();
                    jj_consume_token(RIGHTPARENTHESES);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    //Êü•ÊâæÂáΩÊï∞ÊúâÊó†ÂÆö‰πâ
                    if (fun == null) {
                        errorList.addFunNotDeclared(id);
                    } else {
                        //Êü•ÊâæÂèÇÊï∞ÂàóË°®
                        List<VarInfo> params = fun.getParams();
                        id.type = fun.getReturnType();
                        //ÂΩ¢ÂèÇÊï∞ÈáèÁ±ªÂûãÊ£?Êü?
                        if (params.size() != arList.size()) {
                            errorList.addFunArgSizeError(id);
                        } else {
                            boolean flag = true;
                            for (int i = 0; i < params.size(); i++) {
                                if (!params.get(i).getType().equals(arList.get(i))) {
                                    flag = false;
                                    break;
                                }
                            }
                            if (!flag) {
                                errorList.addFunArgTypeError(id);
                            } else {
                                //true case
                                codeGen.emitRM(codeGen.OP_LDA, codeGen.REG_LP, 0, codeGen.REG_SP, "get new Lp");
                                codeGen.emitRM(codeGen.OP_LDA, codeGen.REG_FP, 1, codeGen.REG_PC, "get new fp");
                                jumpLoc = fun.getLoc();
                                codeGen.emitRM_Abs(codeGen.OP_LDA, codeGen.REG_PC, jumpLoc, "jump to fun");
                                codeGen.emitRM(codeGen.OP_LD, codeGen.REG_FP, ++codeGen.tmpOffset, codeGen.REG_MP, "op: load fp");
                                codeGen.emitRM(codeGen.OP_LD, codeGen.REG_LP, ++codeGen.tmpOffset, codeGen.REG_MP, "op: load lp");
                                codeGen.emitRM(codeGen.OP_LD, codeGen.REG_SP, ++codeGen.tmpOffset, codeGen.REG_MP, "op: load sp");
                            }
                        }
                        id.type = fun.getReturnType();
                    }
                {
                    if (true) return id;
                }
                break;
                case OUTPUT:
                    jj_consume_token(OUTPUT);
                    jj_consume_token(LEFTPARENTHESES);
                    id = expression();
                    jj_consume_token(RIGHTPARENTHESES);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    if (!"int".equals(id.type)) {
                        errorList.addFunArgTypeError(id);
                    }
                    codeGen.emitRO(codeGen.OP_OUT, codeGen.REG_AC, 0, 0, "write ac");
                {
                    if (true) return new Token("void");
                }
                break;
                case INPUT:
                    id = jj_consume_token(INPUT);
                    jj_consume_token(LEFTPARENTHESES);
                    jj_consume_token(RIGHTPARENTHESES);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    codeGen.emitRO(codeGen.OP_IN, codeGen.REG_AC, 0, 0, "read integer value");
                    id.type = "int";
                {
                    if (true) return id;
                }
                break;
                default:
                    jj_la1[23] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    //args -> arg-list | empty
    final public List<String> args() throws ParseException {
        /*@bgen(jjtree) args */
        ASTargs jjtn000 = new ASTargs(JJTARGS);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        List<String> args;
        try {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case OUTPUT:
                case INPUT:
                case ID:
                case NUM:
                case LEFTPARENTHESES:
                case ARRAYELEMENT:
                    args = argList();
                {
                    if (true) return args;
                }
                break;
                default:
                    jj_la1[24] = jj_gen;
                    ;
            }
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
//        args = new ArrayList<String>();
//        args.add("void");
            {
                if (true) return Collections.emptyList();
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    //arg-list -> expression{ , expression}
    final public List<String> argList() throws ParseException {
        /*@bgen(jjtree) argList */
        ASTargList jjtn000 = new ASTargList(JJTARGLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        List<String> args;
        int i = 0;
        try {
            t = expression();
            args = new ArrayList<String>();
            args.add(t.type);
            if ("int".equals(t.type)) {
                codeGen.emitRM(codeGen.OP_ST, codeGen.REG_AC, i++, codeGen.REG_SP, "prepare arg");
            } else {
                codeGen.emitRM(codeGen.OP_ST, codeGen.REG_AC, i, codeGen.REG_SP, "prepare arg");
                i += 50;
            }
            label_7:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                        ;
                        break;
                    default:
                        jj_la1[25] = jj_gen;
                        break label_7;
                }
                jj_consume_token(COMMA);
                t = expression();
                if ("int".equals(t.type)) {
                    codeGen.emitRM(codeGen.OP_ST, codeGen.REG_AC, i++, codeGen.REG_SP, "prepare arg");
                } else {
                    codeGen.emitRM(codeGen.OP_ST, codeGen.REG_AC, i, codeGen.REG_SP, "prepare arg");
                    i += 50;
                }
            }
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            {
                if (true) return args;
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    private boolean jj_2_1(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_1();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(0, xla);
        }
    }

    private boolean jj_2_2(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_2();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(1, xla);
        }
    }

    private boolean jj_2_3(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_3();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(2, xla);
        }
    }

    private boolean jj_2_4(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_4();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(3, xla);
        }
    }

    private boolean jj_2_5(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_5();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(4, xla);
        }
    }

    private boolean jj_2_6(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_6();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(5, xla);
        }
    }

    private boolean jj_2_7(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_7();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(6, xla);
        }
    }

    private boolean jj_2_8(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_8();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(7, xla);
        }
    }

    private boolean jj_2_9(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_9();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(8, xla);
        }
    }

    private boolean jj_2_10(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_10();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(9, xla);
        }
    }

    private boolean jj_2_11(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_11();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(10, xla);
        }
    }

    private boolean jj_3R_57() {
        if (jj_scan_token(LEFTPARENTHESES)) return true;
        if (jj_3R_13()) return true;
        if (jj_scan_token(RIGHTPARENTHESES)) return true;
        return false;
    }

    private boolean jj_3R_54() {
        if (jj_scan_token(EQUAL)) return true;
        return false;
    }

    private boolean jj_3R_53() {
        if (jj_scan_token(GTE)) return true;
        return false;
    }

    private boolean jj_3R_47() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_57()) {
            jj_scanpos = xsp;
            if (jj_3_11()) {
                jj_scanpos = xsp;
                if (jj_3R_58()) {
                    jj_scanpos = xsp;
                    if (jj_3R_59()) return true;
                }
            }
        }
        return false;
    }

    private boolean jj_3R_10() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_20()) {
            jj_scanpos = xsp;
            if (jj_scan_token(19)) return true;
        }
        return false;
    }

    private boolean jj_3R_20() {
        if (jj_3R_13()) return true;
        if (jj_scan_token(SEMICOLON)) return true;
        return false;
    }

    private boolean jj_3R_52() {
        if (jj_scan_token(GT)) return true;
        return false;
    }

    private boolean jj_3R_19() {
        if (jj_scan_token(COMMA)) return true;
        if (jj_3R_18()) return true;
        return false;
    }

    private boolean jj_3R_51() {
        if (jj_scan_token(LT)) return true;
        return false;
    }

    private boolean jj_3R_37() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_9()) {
            jj_scanpos = xsp;
            if (jj_3R_41()) return true;
        }
        return false;
    }

    private boolean jj_3_9() {
        if (jj_scan_token(RETURN)) return true;
        if (jj_scan_token(SEMICOLON)) return true;
        return false;
    }

    private boolean jj_3R_31() {
        if (jj_scan_token(INPUT)) return true;
        if (jj_scan_token(LEFTPARENTHESES)) return true;
        if (jj_scan_token(RIGHTPARENTHESES)) return true;
        return false;
    }

    private boolean jj_3R_50() {
        if (jj_scan_token(LTE)) return true;
        return false;
    }

    private boolean jj_3R_45() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_50()) {
            jj_scanpos = xsp;
            if (jj_3R_51()) {
                jj_scanpos = xsp;
                if (jj_3R_52()) {
                    jj_scanpos = xsp;
                    if (jj_3R_53()) {
                        jj_scanpos = xsp;
                        if (jj_3R_54()) {
                            jj_scanpos = xsp;
                            if (jj_3R_55()) return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3R_64() {
        if (jj_scan_token(DIVIDE)) return true;
        return false;
    }

    private boolean jj_3R_26() {
        if (jj_3R_37()) return true;
        return false;
    }

    private boolean jj_3R_28() {
        if (jj_scan_token(ARRAYELEMENT)) return true;
        if (jj_3R_13()) return true;
        if (jj_scan_token(RIGHTBRACKET)) return true;
        return false;
    }

    private boolean jj_3R_25() {
        if (jj_3R_36()) return true;
        return false;
    }

    private boolean jj_3_7() {
        if (jj_3R_12()) return true;
        return false;
    }

    private boolean jj_3R_30() {
        if (jj_scan_token(OUTPUT)) return true;
        if (jj_scan_token(LEFTPARENTHESES)) return true;
        if (jj_3R_13()) return true;
        if (jj_scan_token(RIGHTPARENTHESES)) return true;
        return false;
    }

    private boolean jj_3R_63() {
        if (jj_scan_token(TIMES)) return true;
        return false;
    }

    private boolean jj_3R_60() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_63()) {
            jj_scanpos = xsp;
            if (jj_3R_64()) return true;
        }
        return false;
    }

    private boolean jj_3R_9() {
        if (jj_3R_18()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_19()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3_6() {
        if (jj_3R_11()) return true;
        return false;
    }

    private boolean jj_3_5() {
        if (jj_3R_10()) return true;
        return false;
    }

    private boolean jj_3R_14() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_5()) {
            jj_scanpos = xsp;
            if (jj_3_6()) {
                jj_scanpos = xsp;
                if (jj_3_7()) {
                    jj_scanpos = xsp;
                    if (jj_3R_25()) {
                        jj_scanpos = xsp;
                        if (jj_3R_26()) return true;
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3R_62() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_34() {
        if (jj_3R_14()) return true;
        return false;
    }

    private boolean jj_3R_61() {
        if (jj_scan_token(PLUS)) return true;
        return false;
    }

    private boolean jj_3R_49() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_61()) {
            jj_scanpos = xsp;
            if (jj_3R_62()) return true;
        }
        return false;
    }

    private boolean jj_3R_22() {
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_34()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_33() {
        if (jj_3R_8()) return true;
        return false;
    }

    private boolean jj_3_3() {
        if (jj_3R_9()) return true;
        return false;
    }

    private boolean jj_3R_17() {
        if (jj_scan_token(INT)) return true;
        if (jj_scan_token(ARRAYELEMENT)) return true;
        if (jj_scan_token(NUM)) return true;
        if (jj_scan_token(RIGHTBRACKET)) return true;
        if (jj_scan_token(SEMICOLON)) return true;
        return false;
    }

    private boolean jj_3R_15() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_27()) {
            jj_scanpos = xsp;
            if (jj_3R_28()) return true;
        }
        return false;
    }

    private boolean jj_3R_27() {
        if (jj_scan_token(ID)) return true;
        return false;
    }

    private boolean jj_3R_21() {
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_33()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_36() {
        if (jj_scan_token(WHILE)) return true;
        if (jj_scan_token(LEFTPARENTHESES)) return true;
        if (jj_3R_13()) return true;
        if (jj_scan_token(RIGHTPARENTHESES)) return true;
        if (jj_3R_14()) return true;
        return false;
    }

    private boolean jj_3R_24() {
        if (jj_3R_35()) return true;
        return false;
    }

    private boolean jj_3R_48() {
        if (jj_3R_60()) return true;
        if (jj_3R_47()) return true;
        return false;
    }

    private boolean jj_3R_8() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_2()) {
            jj_scanpos = xsp;
            if (jj_3R_17()) return true;
        }
        return false;
    }

    private boolean jj_3_2() {
        if (jj_scan_token(INT)) return true;
        if (jj_scan_token(ID)) return true;
        if (jj_scan_token(SEMICOLON)) return true;
        return false;
    }

    private boolean jj_3R_43() {
        if (jj_3R_47()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_48()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_56() {
        if (jj_scan_token(COMMA)) return true;
        if (jj_3R_13()) return true;
        return false;
    }

    private boolean jj_3R_23() {
        if (jj_scan_token(IF)) return true;
        if (jj_scan_token(LEFTPARENTHESES)) return true;
        if (jj_3R_13()) return true;
        if (jj_scan_token(RIGHTPARENTHESES)) return true;
        if (jj_3R_14()) return true;
        return false;
    }

    private boolean jj_3R_40() {
        if (jj_3R_45()) return true;
        if (jj_3R_39()) return true;
        return false;
    }

    private boolean jj_3R_35() {
        if (jj_3R_39()) return true;
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_40()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3R_11() {
        if (jj_scan_token(LEFTBRACES)) return true;
        if (jj_3R_21()) return true;
        if (jj_3R_22()) return true;
        if (jj_scan_token(RIGHTBRACES)) return true;
        return false;
    }

    private boolean jj_3R_46() {
        if (jj_3R_13()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_56()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3_1() {
        if (jj_3R_8()) return true;
        return false;
    }

    private boolean jj_3R_16() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_29()) {
            jj_scanpos = xsp;
            if (jj_3R_30()) {
                jj_scanpos = xsp;
                if (jj_3R_31()) return true;
            }
        }
        return false;
    }

    private boolean jj_3R_29() {
        if (jj_scan_token(ID)) return true;
        if (jj_scan_token(LEFTPARENTHESES)) return true;
        if (jj_3R_38()) return true;
        if (jj_scan_token(RIGHTPARENTHESES)) return true;
        return false;
    }

    private boolean jj_3R_13() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_10()) {
            jj_scanpos = xsp;
            if (jj_3R_24()) return true;
        }
        return false;
    }

    private boolean jj_3_10() {
        if (jj_3R_15()) return true;
        if (jj_scan_token(ASSIGN)) return true;
        if (jj_3R_13()) return true;
        return false;
    }

    private boolean jj_3R_32() {
        if (jj_scan_token(INT)) return true;
        if (jj_scan_token(ARRAYELEMENT)) return true;
        if (jj_scan_token(RIGHTBRACKET)) return true;
        return false;
    }

    private boolean jj_3R_44() {
        if (jj_3R_49()) return true;
        if (jj_3R_43()) return true;
        return false;
    }

    private boolean jj_3R_59() {
        if (jj_scan_token(NUM)) return true;
        return false;
    }

    private boolean jj_3R_42() {
        if (jj_3R_46()) return true;
        return false;
    }

    private boolean jj_3_4() {
        if (jj_scan_token(INT)) return true;
        if (jj_scan_token(ID)) return true;
        return false;
    }

    private boolean jj_3R_18() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_4()) {
            jj_scanpos = xsp;
            if (jj_3R_32()) return true;
        }
        return false;
    }

    private boolean jj_3R_12() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_8()) {
            jj_scanpos = xsp;
            if (jj_3R_23()) return true;
        }
        return false;
    }

    private boolean jj_3_8() {
        if (jj_scan_token(IF)) return true;
        if (jj_scan_token(LEFTPARENTHESES)) return true;
        if (jj_3R_13()) return true;
        if (jj_scan_token(RIGHTPARENTHESES)) return true;
        if (jj_3R_14()) return true;
        if (jj_scan_token(ELSE)) return true;
        if (jj_3R_14()) return true;
        return false;
    }

    private boolean jj_3R_39() {
        if (jj_3R_43()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_44()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_58() {
        if (jj_3R_15()) return true;
        return false;
    }

    private boolean jj_3R_38() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_42()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3R_41() {
        if (jj_scan_token(RETURN)) return true;
        if (jj_3R_13()) return true;
        if (jj_scan_token(SEMICOLON)) return true;
        return false;
    }

    private boolean jj_3_11() {
        if (jj_3R_16()) return true;
        return false;
    }

    private boolean jj_3R_55() {
        if (jj_scan_token(NOTEQUAL)) return true;
        return false;
    }

    /**
     * Generated Token Manager.
     */
    public MyCompilerTokenManager token_source;
    SimpleCharStream jj_input_stream;
    /**
     * Current token.
     */
    public Token token;
    /**
     * Next token.
     */
    public Token jj_nt;
    private int jj_ntk;
    private Token jj_scanpos, jj_lastpos;
    private int jj_la;
    private int jj_gen;
    final private int[] jj_la1 = new int[26];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;

    static {
        jj_la1_init_0();
        jj_la1_init_1();
    }

    private static void jj_la1_init_0() {
        jj_la1_0 = new int[]{0x1400, 0x1400, 0x400, 0x1400, 0x1000, 0x8000000, 0x400, 0x400, 0x100d6a80, 0xa00, 0x100d6000, 0x80, 0x800, 0x10056000, 0x10000, 0x300000, 0x300000, 0x1800000, 0x6000000, 0x1800000, 0x6000000, 0x10000000, 0x50000, 0x16000, 0x10056000, 0x8000000,};
    }

    private static void jj_la1_init_1() {
        jj_la1_1 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x2, 0x0, 0x0, 0x2, 0x2, 0xf0, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x2, 0x0,};
    }

    final private JJCalls[] jj_2_rtns = new JJCalls[11];
    private boolean jj_rescan = false;
    private int jj_gc = 0;

    /**
     * Constructor with InputStream.
     */
    public MyCompiler(java.io.InputStream stream) {
        this(stream, null);
    }

    /**
     * Constructor with InputStream and supplied encoding
     */
    public MyCompiler(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new MyCompilerTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 26; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream stream) {
        ReInit(stream, null);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jjtree.reset();
        jj_gen = 0;
        for (int i = 0; i < 26; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Constructor.
     */
    public MyCompiler(java.io.Reader stream) {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new MyCompilerTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 26; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jjtree.reset();
        jj_gen = 0;
        for (int i = 0; i < 26; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Constructor with generated Token Manager.
     */
    public MyCompiler(MyCompilerTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 26; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Reinitialise.
     */
    public void ReInit(MyCompilerTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jjtree.reset();
        jj_gen = 0;
        for (int i = 0; i < 26; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            if (++jj_gc > 100) {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.length; i++) {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null) {
                        if (c.gen < jj_gen) c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    static private final class LookaheadSuccess extends java.lang.Error {
    }

    final private LookaheadSuccess jj_ls = new LookaheadSuccess();

    private boolean jj_scan_token(int kind) {
        if (jj_scanpos == jj_lastpos) {
            jj_la--;
            if (jj_scanpos.next == null) {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
            } else {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        } else {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan) {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos) {
                i++;
                tok = tok.next;
            }
            if (tok != null) jj_add_error_token(kind, i);
        }
        if (jj_scanpos.kind != kind) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
        return false;
    }


    /**
     * Get the next Token.
     */
    final public Token getNextToken() {
        if (token.next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    /**
     * Get the specific Token.
     */
    final public Token getToken(int index) {
        Token t = token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) t = t.next;
            else t = t.next = token_source.getNextToken();
        }
        return t;
    }

    private int jj_ntk() {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
    private int[] jj_expentry;
    private int jj_kind = -1;
    private int[] jj_lasttokens = new int[100];
    private int jj_endpos;

    private void jj_add_error_token(int kind, int pos) {
        if (pos >= 100) return;
        if (pos == jj_endpos + 1) {
            jj_lasttokens[jj_endpos++] = kind;
        } else if (jj_endpos != 0) {
            jj_expentry = new int[jj_endpos];
            for (int i = 0; i < jj_endpos; i++) {
                jj_expentry[i] = jj_lasttokens[i];
            }
            jj_entries_loop:
            for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext(); ) {
                int[] oldentry = (int[]) (it.next());
                if (oldentry.length == jj_expentry.length) {
                    for (int i = 0; i < jj_expentry.length; i++) {
                        if (oldentry[i] != jj_expentry[i]) {
                            continue jj_entries_loop;
                        }
                    }
                    jj_expentries.add(jj_expentry);
                    break jj_entries_loop;
                }
            }
            if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    /**
     * Generate ParseException.
     */
    public ParseException generateParseException() {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[40];
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 26; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 40; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    /**
     * Enable tracing.
     */
    final public void enable_tracing() {
    }

    /**
     * Disable tracing.
     */
    final public void disable_tracing() {
    }

    private void jj_rescan_token() {
        jj_rescan = true;
        for (int i = 0; i < 11; i++) {
            try {
                JJCalls p = jj_2_rtns[i];
                do {
                    if (p.gen > jj_gen) {
                        jj_la = p.arg;
                        jj_lastpos = jj_scanpos = p.first;
                        switch (i) {
                            case 0:
                                jj_3_1();
                                break;
                            case 1:
                                jj_3_2();
                                break;
                            case 2:
                                jj_3_3();
                                break;
                            case 3:
                                jj_3_4();
                                break;
                            case 4:
                                jj_3_5();
                                break;
                            case 5:
                                jj_3_6();
                                break;
                            case 6:
                                jj_3_7();
                                break;
                            case 7:
                                jj_3_8();
                                break;
                            case 8:
                                jj_3_9();
                                break;
                            case 9:
                                jj_3_10();
                                break;
                            case 10:
                                jj_3_11();
                                break;
                        }
                    }
                    p = p.next;
                } while (p != null);
            } catch (LookaheadSuccess ls) {
            }
        }
        jj_rescan = false;
    }

    private void jj_save(int index, int xla) {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen) {
            if (p.next == null) {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    static final class JJCalls {
        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
